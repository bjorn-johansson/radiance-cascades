
#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; //TODO: explore better groups and compare gpu scheduling perf

layout(binding = 2) uniform sampler2DArray _cascadeSamplers; //read
layout(binding = 2, rgba32f) uniform writeonly image2DArray _cascadeImages; //write

uniform int _sourceLayerIndex;
uniform int _Merge;

const int CASCADE_TEXTURE_SIDE = 512;
const int CASCADE_SCALING = 4;

const int CASCADE_PROBE_SIDES[7] = { 2, 4, 8, 16, 32, 64, 128};



vec4 BilinearWeights(vec2 ratio) {
    return vec4(
    (1.0 - ratio.x) * (1.0 - ratio.y),
    ratio.x * (1.0 - ratio.y),
    (1.0 - ratio.x) * ratio.y,
    ratio.x * ratio.y
    );
}

int CoordToIndex(ivec2 coord, int width){
    return coord.y * width + coord.x;
}

ivec2 ProbeIndexToCoord(int index, int width, ivec2 probeID) {
    ivec2 coord = ivec2(index % width, index / width);
    return probeID * width + coord;
}

vec3 SampleProbe(ivec2 probeID, int DirBlockIndex) {
    int width = CASCADE_PROBE_SIDES[_sourceLayerIndex];
    ivec2 baseCoord = ProbeIndexToCoord(DirBlockIndex, width, probeID);

    vec3 radiance = vec3(0.0);
    for (int i = 0; i < CASCADE_SCALING; i++) {
        ivec2 fetchCoord = baseCoord + ivec2(i, 0); //groups of 4 indicies will always share y value.
        radiance += texelFetch(_cascadeSamplers, ivec3(fetchCoord, _sourceLayerIndex), 0).rgb;
    }
    radiance *= 0.25f;

    return radiance;
}

void main() {
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    
    ivec2 tgtCoordInProbe = id % CASCADE_PROBE_SIDES[_sourceLayerIndex - 1];
    vec2 tgtProbeGridCoord = id / float(CASCADE_PROBE_SIDES[_sourceLayerIndex - 1]);

    //directional index inside the probe that we are writing to
    int tgtDirIndex = CoordToIndex(tgtCoordInProbe, CASCADE_PROBE_SIDES[_sourceLayerIndex - 1]);
    //scale that up to get the 4 source indicies going in the directions that are closest to our target ray.
    int srcIndexBlock = tgtDirIndex * CASCADE_SCALING;

    vec2 srcProbeGridCoord = id / float(CASCADE_PROBE_SIDES[_sourceLayerIndex]) -vec2(0.5f);
    ivec2 base = ivec2(floor(srcProbeGridCoord));
    vec2 frac = fract(srcProbeGridCoord);
    vec4 weight = BilinearWeights(frac);
    
    int srcProbeGridSide = CASCADE_TEXTURE_SIDE / CASCADE_PROBE_SIDES[_sourceLayerIndex];
    base = clamp(base, ivec2(0), ivec2(srcProbeGridSide - 2));
    
    int dir = (_sourceLayerIndex % 2) * -2 + 1;
    vec3 P00 = SampleProbe(base, srcIndexBlock);
    vec3 P10 = SampleProbe(base + ivec2(1, 0), srcIndexBlock);
    vec3 P01 = SampleProbe(base + ivec2(0, 1), srcIndexBlock);
    vec3 P11 = SampleProbe(base + ivec2(1, 1), srcIndexBlock);
    
    vec3 result = 
    P00 * weight.x +
    P10 * weight.y + 
    P01 * weight.z + 
    P11 * weight.w;

    vec4 targetCol = texelFetch(_cascadeSamplers, ivec3(id, _sourceLayerIndex - 1), 0);
    result *= (1.f - targetCol.a); //did we get blocked in the lower cascade?
    result += targetCol.rgb;
    if (_Merge == 1)
        imageStore(_cascadeImages, ivec3( id, _sourceLayerIndex - 1), vec4(result, targetCol.a));
    return;

    vec2 uv = id % CASCADE_PROBE_SIDES[ _sourceLayerIndex - 1] / float(CASCADE_PROBE_SIDES[ _sourceLayerIndex - 1]);
    uv /= 2;
    if(targetCol.r < -0.5 || targetCol.g < -0.5 || targetCol.b < -0.5)
    {
        uv *= 0;
        targetCol *= 0;
        //targetCol.b = 1f;
    }
    if(_sourceLayerIndex == 3)
        imageStore(_cascadeImages, ivec3(id, _sourceLayerIndex - 1), vec4(uv + targetCol.rg, targetCol.b, targetCol.a));
    
    
}

