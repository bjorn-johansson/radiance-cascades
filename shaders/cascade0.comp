
#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; //TODO: explore better groups and compare gpu scheduling perf

//bitmap is 1 cell/uint. 2 least significant bits denote type:
//  00 = 0 = empty
//  01 = 1 = wall
//  10 = 2 = emissive
//  11 = 3 = transmissive - unused for now
//the remaining 6 denote material ID: 11111100
layout(binding = 0) uniform usampler2D _bitmapTexture;              //READ
layout(binding = 1) uniform sampler2D _materialAtlas;               //READ
layout(binding = 2, rgba32f) uniform writeonly image2DArray _cascadeTextures;   //WRITE

const float PI = 3.14159265359;

const vec3 airAbsorption = vec3(0.05f);

const uint WALL_MASK = 0x1;
const uint EMITTER_MASK = 0x2;
const uint MATERIAL_MASK = 0xFC;

const float BASE_RAY_LENGTH = 4;

//these 3 differ between cascade levels.
const int CASCADE_TEXTURE_WIDTH = 512;
const int CASCADE_LEVEL = 0;
const float RAY_LENGTH = BASE_RAY_LENGTH * pow(2, CASCADE_LEVEL); //leaving this const instead of uniform to allow for ray loop unrolling

const int PROBE_CLUSTER_SIDE = int(pow(2, CASCADE_LEVEL + 1));
const int PROBE_COUNT = int(pow(CASCADE_TEXTURE_WIDTH / PROBE_CLUSTER_SIDE, 2));

const int RAY_COUNT = PROBE_CLUSTER_SIDE * PROBE_CLUSTER_SIDE;  //4x scaling, not folling penumbra condition(2x scaling), but easier to work with for now 
const int RAY_STEPS = int(floor(RAY_LENGTH * sqrt(2))) + 1;


ivec2 CellToTexel(ivec2 cell){
    return ivec2(cell + textureSize(_bitmapTexture, 0).xy * 0.5f);
}

//DDA raytracing
void main() {
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);

    ivec2 bitmapSize = textureSize(_bitmapTexture, 0);
    vec2 probeUV = (id - id % PROBE_CLUSTER_SIDE + 0.5f) / float(CASCADE_TEXTURE_WIDTH);
    vec2 ro = (probeUV - 0.5) * bitmapSize; // center origin, stretched to cover scene.

    ivec2 cell = ivec2(floor(ro));

    uint ri = (id.y % PROBE_CLUSTER_SIDE) * PROBE_CLUSTER_SIDE + (id.x % PROBE_CLUSTER_SIDE);
    float angle = 2.f * PI * ((float(ri) + 0.5f) / RAY_COUNT);
    vec2 rd = vec2(cos(angle), sin(angle));

    vec2 roFract = ro - cell;
    ivec2 step = ivec2(sign(rd));
    
    vec2 rayUnitStepSize = vec2(sqrt(1 + (rd.y / rd.x) * (rd.y / rd.x)),
    sqrt(1 + (rd.x / rd.y) * (rd.x / rd.y)));
    // vec2(1.5f, 1.5f); //diagonals have 1.5f distance between squares
    
    // going in the direction of the ray, how far will we travel through each column/row?
    vec2 distToEdge; 
    distToEdge.x = float(step.x >= 0.f) * (1 - roFract.x) * rayUnitStepSize.x;  //positive dir
    distToEdge.x += float(step.x < 0.f) * roFract.x * rayUnitStepSize.x;        //negative dir

    distToEdge.y = float(step.y >= 0.f) * (1 - roFract.y) * rayUnitStepSize.y;
    distToEdge.y += float(step.y < 0.f) * roFract.y * rayUnitStepSize.y;
    
    vec3 radiance = vec3(0.f);
    float prevDist = 0.f;
    float rayIsAlive = 1.0f;
    float gotBlocked = 0.f; //tells other cascades if this hit a wall
    float t = 0.f;          //total distance traveled

    for(int i = 0; i < RAY_STEPS; i++) {
        //get object data of the current cell
        uint cellData = texelFetch(_bitmapTexture, CellToTexel(cell), 0).r * uint(max(cell.x, cell.y) < min(bitmapSize.x, bitmapSize.y));
        
        //object bools
        float blocks = float((cellData & WALL_MASK) != 0u);
        float emits = float((cellData & EMITTER_MASK) != 0u);
        float transmits = 1.f - blocks;
        
        ////get the emissive material. If it isn't emissive set index to 0. should improve cache hits? TODO: try changing this and compare with tracy!
        //uint matID = (cellData >> 2) * uint(emits);
        //ivec2 matTexelCoord = ivec2(matID % 8, matID / 8);
        //vec4 material = texelFetch(_materialAtlas, matTexelCoord, 0); //0 vector at indx 0
        //vec3 emission = material.rgb * material.a;
        
        vec3 tempEmission = emits * vec3(0.f,1f,1f);
        
        //gather radiance
        radiance += rayIsAlive * tempEmission * exp(-airAbsorption * (t / 100)); //beers law for attenuation
        //a wall, a light or reaching max distance kills the ray.
        rayIsAlive *= (1.f - blocks) * (1.f - emits) * sign(RAY_LENGTH - t);
        gotBlocked = max(gotBlocked, blocks);
        
        //advance DDA
        float nextDist = min(distToEdge.x, distToEdge.y);
        t += nextDist - prevDist;
        prevDist = nextDist;
        
        int xCloser = int(distToEdge.x < distToEdge.y);
        int yCloser = 1 - xCloser;
        
        cell.x += xCloser * step.x;
        distToEdge.x += xCloser * rayUnitStepSize.x;
        cell.y += yCloser * step.y;
        distToEdge.x += yCloser * rayUnitStepSize.y;

    }
    //store collected ray data into cascade

    //radiance *= 0.25f;
    if(radiance.r > 1.1f)
    radiance.b = 1.f;
    uvec2 rayCoordInProbe = id % PROBE_CLUSTER_SIDE;
    vec2 uvInProbe = vec2(rayCoordInProbe) / float(PROBE_CLUSTER_SIDE);
    imageStore(_cascadeTextures, ivec3(id, CASCADE_LEVEL), vec4(radiance, gotBlocked));

    //imageStore(_cascadeTextures, ivec3(id, CASCADE_LEVEL), vec4(radiance, 1));
}









/*things to try:

    * TODO: make a compiler to allow for multiple different cascade kernels in a single file.
     would look like this:
     
            #version 430 core
            #kernel Cascade0
            #kernel Cascade1
            
            uniforms
            consts
            
            layout(local_size_x = 4, local_size_y = 1, local_size_z = 1) in;
            void Cascade0(){
            }
            layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
            void Cascade1(){
            }
        
    * try splitting long high-cascade rays into multiple threads to avoid having an individual thread march 400 steps
    - perhaps 1 group per ray, and then we accumulate the total with shared memory somehow?

    * add, transmissives, accumulate attenuation stored in every cell, we should get volumetrics for little extra cost
    
    - to do it travelDist through a cell is needed:
    float travelDist = nextDist - prevDist;  //  can be used to partially affect ray based on volume
    
    
    * wall bounces / refraction:
    change wall hits to a bounce and redirect ray. Would require normals.
    would also require calculating the new angle every cell, perhaps doable with tables and set amount of wall angles?
    if done could also include refraction through the above transmissives
    
    
//C0 is just the diagonals. we could use this for C0
const vec2 rayDirections[4] = vec2[4](
vec2(1, 1),
vec2(1, -1),
vec2(-1, 1),
vec2(-1, -1)
);
    
    used when only 2 bits denoted type:
//uint getTypeID(ivec2 gridCell) { 
//    int cellX = gridCell.x / 4;
//    int cellInTexel = gridCell.x % 4;
//
//    uint texel = texelFetch(uBitmapTexture, ivec2(cellX, gridCell.y), 0).r;
//    uint shift = uint(cellInTexel) * 2u;
//
//    return (texel >> shift) & TYPE_MASK; //only take the 2 relevant bits
//}

    old kinda fucky method to get texel coords:
    
    uvec2 probeTexelCoord = gl_WorkGroupID.xy * (gl_WorkGroupSize.xy / RAY_COUNT);
    ivec2 rayTexelCoord = ivec2(probeTexelCoord + gl_LocalInvocationID.xy % (RAY_COUNT / 2));
    //uv map for now
    radiance = vec3(gl_LocalInvocationID.xy % (RAY_COUNT / 2), 0.f);
    imageStore(uCascade0, rayTexelCoord, vec4(radiance, 1.f - gotBlocked));



*/
 