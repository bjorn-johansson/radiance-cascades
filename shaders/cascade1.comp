
#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; //TODO: explore better groups and compare gpu scheduling perf

//bitmap is 1 cell/uint. 2 least significant bits denote type:
//  00 = 0 = empty
//  01 = 1 = wall
//  10 = 2 = emissive
//  11 = 3 = transmissive - unused for now
//the remaining 6 denote material ID: 11111100
layout(binding = 0) uniform usampler2D uBitmapTexture;              //READ
layout(binding = 1) uniform sampler2D uMaterialAtlas;               //READ
layout(binding = 2, rgba32f) uniform writeonly image2D uCascade0;   //WRITE

const float PI = 3.14159265359;

const vec3 airAbsorption = vec3(0.05f);

const uint TYPE_MASK = 0x3;
const uint MATERIAL_MASK = 0xFC;
const bvec4 BLOCKS_RAY = bvec4(false, true, true, false); //TODO: change to bitmasks?
const bvec4 IS_EMITTER = bvec4(false, false, true, false);//TODO: change to bitmasks?

const int CASCADE_TEXTURE_WIDTH = 256;
const int PROBE_COUNT = 4096;
const int RAY_COUNT = 16;       //4x scaling, not folling penumbra condition(2x scaling), but easier to work with for now
const float RAY_LENGTH = 16;    //const to allow for ray loop unrolling
const int RAY_STEPS = int(floor(RAY_LENGTH * sqrt(2))) + 1;

ivec2 CellToTexel(ivec2 cell){
    return ivec2(cell + textureSize(uBitmapTexture, 0).xy * 0.5f);
}

//DDA raytracing
void main() {

    //1 workgroup per probe
    vec2 ro = (vec2(gl_WorkGroupID) / vec2(gl_NumWorkGroups)) - 0.5f; //-0.5 to 0.5
    ro *= textureSize(uBitmapTexture, 0).xy; //worldSpace (center origin)

    ivec2 cell = ivec2(floor(ro));

    uint ri = gl_LocalInvocationIndex % RAY_COUNT;
    float ra = 2.f * PI * ((float(ri) + 0.5f) / RAY_COUNT);
    vec2 rd = vec2(cos(ra), sin(ra));

    vec2 roFract = ro - cell;
    ivec2 step = ivec2(sign(rd));
    
    vec2 rayUnitStepSize = vec2(sqrt(1 + (rd.y / rd.x) * (rd.y / rd.x)),
                                sqrt(1 + (rd.x / rd.y) * (rd.x / rd.y)));
    
    // going in the direction of the ray, how far will we travel through each column/row?
    vec2 distToEdge;
    distToEdge.x = float(step.x >= 0.f) * (1 - roFract.x) * rayUnitStepSize.x;  //positive dir
    distToEdge.x += float(step.x < 0.f) * roFract.x * rayUnitStepSize.x;        //negative dir

    distToEdge.y = float(step.y >= 0.f) * (1 - roFract.y) * rayUnitStepSize.y;
    distToEdge.y += float(step.y < 0.f) * roFract.y * rayUnitStepSize.y;

    vec3 radiance = vec3(0.f);
    float prevDist = 0.f;
    float rayIsAlive = 1.0f;
    float gotBlocked = 0.f; //tells other cascades if this hit a wall
    float t = 0.f; //total distance traveled

    for(int i = 0; i < RAY_STEPS; i++) {
        //get object data of the current cell
        uint cellData = texelFetch(uBitmapTexture, CellToTexel(cell), 0).r;
        uint typeID = (cellData & TYPE_MASK);
        //object bools
        float blocks = float(BLOCKS_RAY[typeID]);
        float emits = float(IS_EMITTER[typeID]);
        float transmits = 1.f - blocks;



        //get the emissive material. If it isn't emissive set index to 0 to improve cache hits. TODO: try changing this and compare with tracy!
        uint matID = (cellData >> 2) * uint(emits);
        ivec2 matTexelCoord = ivec2(matID % 8, matID / 8);
        vec4 material = texelFetch(uMaterialAtlas, matTexelCoord, 0); //0 vector at indx 0
        vec3 emission = material.rgb * material.a;

        //gather radiance
        radiance += rayIsAlive * emission * exp(-airAbsorption * t); //beers law for attenuation


        //a wall, a light or reaching max distance kills the ray. 
        rayIsAlive = min(min(rayIsAlive, (1.f - blocks)), float(t < RAY_LENGTH));
        gotBlocked = max(gotBlocked, blocks);

        //advance DDA
        float nextDist = min(distToEdge.x, distToEdge.y);
        t += nextDist - prevDist;
        prevDist = nextDist;

        int xCloser = int(distToEdge.x < distToEdge.y);
        int yCloser = 1 - xCloser;

        cell.x += xCloser * step.x;
        distToEdge.x += xCloser * rayUnitStepSize.x;
        cell.y += yCloser * step.y;
        distToEdge.x += yCloser * rayUnitStepSize.y;

    }
    //store collected ray data into cascade

    const int probeSide = int(sqrt(RAY_COUNT));
    
    uvec2 globalID = gl_GlobalInvocationID.xy;
    uint globalThreadIndex = globalID.y * CASCADE_TEXTURE_WIDTH + globalID.x;
    
    uint probeIndex = globalThreadIndex / RAY_COUNT;
    uint rayIndex = globalThreadIndex % RAY_COUNT;

    uvec2 rayCoordInProbe = uvec2(rayIndex % probeSide, rayIndex / probeSide);
    
    const uint probesPerRow = uint(CASCADE_TEXTURE_WIDTH / probeSide);
    uvec2 probeGridCoord = uvec2(probeIndex % probesPerRow, probeIndex / probesPerRow); //assuming 4:3 for now
    
    uvec2 texelCoord = probeGridCoord * probeSide + rayCoordInProbe;

    //just do UVs for now
    vec2 uvInProbe = vec2(rayCoordInProbe) / float(probeSide);
    
    imageStore(uCascade0, ivec2(texelCoord), vec4(uvInProbe, 0.0, 1.0));
}
